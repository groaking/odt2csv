# This file converts an OOMMF DataTable output (ODT) into a CSV-like file
# Created on 2023-07-08 by Samarthya Lykamanuella

# For parsing the input/output file name arguments
# (Default package from Python installation. No PIP extension required)
import optparse

# For separating filenames/paths
# (Default package from Python installation. No PIP extension required)
import os

def despacifier(str_):
    '''
    A simple function that removes redundant (double) space characters
    '''
    while str_.__contains__('  '):
        str_ = str_.replace('  ', ' ')
    # Ensures that the string does not start or end in blank spaces
    str_ = str_.strip()
    return str_

def remove_empty(input_list=[]):
    '''
    Remover of empty list items or list items with only blank spaces
    Assumes each item in input_list is a string
    '''
    # The new list
    output_list = []
    
    # Read the input list/array
    for a in input_list:
        l = a.strip()
        if len(l) == 0:
            # The list item is empty
            # No need to append to the new list
            pass
        else:
            # You've made it, item list!
            output_list.append(l)
    
    # Return the sanitized list
    return output_list

def space2comma(str_):
    '''
    Turn all space characters into commas
    '''
    # Despacify!
    str_ = despacifier(str_)
    # Convert spaces to commas
    str_ = str_.replace(' ', ',')
    return str_

# Setting up the argument parser
# SOURCE: https://www.geeksforgeeks.org/optparse-module-in-python
# SOURCE: https://docs.python.org/3/library/optparse.html
parser = optparse.OptionParser(
epilog='Converts an ODT file generated by OOMMF into a CSV-formatted file\nCreated by Samarthya Lykamanuella on 2023-07-08'
)
parser.add_option('-i', '--input', dest='input', type='string', help='the input ODT file to convert to CSV')
parser.add_option('-o', '--output', dest='output', type='string', help='the output CSV file')

# Parse arguments
(options, args) = parser.parse_args()

# The input file
fi = options.input

# Detecting if the input file is specified
if fi == None:
    print('Input file is not specified. Please do.')
    exit(1)

# The output file
fo = options.output

# Detecting whether the output file is specified
if fo == None:
    # SOURCE: https://stackoverflow.com/a/678242
    fo = os.path.splitext(fi)[0] + '.csv'
else:
    # Ensuring that the filename always ends in 'csv'
    if fo[-4:] != '.csv':
        fo += '.csv'

# Console logging
print(f'{fi} --> {fo}')

# Truncating the output file; overwriting
# SOURCE: https://stackoverflow.com/a/2769090
open(fo, 'w').close()

# Opening the files
read_in = open(fi, 'r')
write_out = open(fo, 'a')

# Reading the input file to convert
for l in read_in:
    
    # Stripping redundant blank chars
    l = l.strip()
    
    # Detecting column header
    if l[:10] == '# Columns:':
        l = despacifier(l[10:])
        
        # First step: detecting the existence of the opening '{' delimeter
        # The variable 'p' is retained for historical reasons
        # 'ch' stands for 'column header'
        p = ch = remove_empty(l.split('{'))
        
        # The sanitized column header
        sanitized_ch = ''
        
        # Next step: after splitting the line by the existence of '{',
        # find the closing '}' delimeter
        for q in p:
            if q.__contains__('}'):
                r = remove_empty(q.split('}'))
                # Append the first item of r, r[0], which is the only item encapsulated by {...}
                sanitized_ch += "\"" + r[0] + "\","
                
                # r[1], r[2], etc., if they exist, are just regular substring
                # that do not contain blank spaces
                # Do normal splitting-by-whitespace if they exist
                if len(r) > 1:
                    for s in r[1].split(' '):
                        sanitized_ch += "\"" + s + "\","
            
            # If no '}' delimeter is found, then the substring has no blank space in it
            # Do normal splitting-by-whitespace
            else:
                r = remove_empty(q.split(' '))
                for s in r:
                    sanitized_ch += "\"" + s + "\","
        
        # Trim trailing commas
        sanitized_ch = sanitized_ch[:-1]
        
        # Append this header to the first line of the output file
        write_out.write(sanitized_ch + '\n')
        continue
    
    # Detecting general comments
    elif l[:1] == '#':
        # Pass this one; no need to process this line,
        # which is a comment line
        continue
    
    # Data rows
    else:
        # Convert this row full of numbers into csv-compatible row
        new_l = space2comma(l) + '\n'
        write_out.write(new_l)
        continue

# Closing the files
read_in.close()
write_out.close()
